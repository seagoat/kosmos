#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Thu Aug  2 14:53:57 2018 by generateDS.py version 2.29.19.
# Python 3.5.4 |Anaconda custom (64-bit)| (default, Oct  5 2017, 02:58:14)  [GCC 4.2.1 Compatible Clang 4.0.1 (tags/RELEASE_401/final)]
#
# Command line options:
#   ('-o', 'emails.py')
#
# Command line arguments:
#   ../../schema/emails.xsd
#
# Command line:
#   /Users/brian/anaconda/bin/generateDS -o "emails.py" ../../schema/emails.xsd
#
# Current working directory (os.getcwd()):
#   parser
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
try:
    from lxml import etree as etree_
except ImportError:
    from xml.etree import ElementTree as etree_


Validate_simpletypes_ = True
if sys.version_info.major == 2:
    BaseStrType_ = basestring
else:
    BaseStrType_ = str


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        try:
            parser = etree_.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree_.XMLParser()
    element = etree_.fromstring(instring, parser=parser, **kwargs)
    return element

#
# Namespace prefix definition table (and other attributes, too)
#
# The module generatedsnamespaces, if it is importable, must contain
# a dictionary named GeneratedsNamespaceDefs.  This Python dictionary
# should map element type names (strings) to XML schema namespace prefix
# definitions.  The export method for any class for which there is
# a namespace prefix definition, will export that definition in the
# XML representation of that element.  See the export method of
# any generated element type class for a example of the use of this
# table.
# A sample table is:
#
#     # File: generatedsnamespaces.py
#
#     GenerateDSNamespaceDefs = {
#         "ElementtypeA": "http://www.xxx.com/namespaceA",
#         "ElementtypeB": "http://www.xxx.com/namespaceB",
#     }
#

try:
    from generatedsnamespaces import GenerateDSNamespaceDefs as GenerateDSNamespaceDefs_
except ImportError:
    GenerateDSNamespaceDefs_ = {}

#
# The root super-class for element type classes
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:
    
    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(
                                hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))
        @staticmethod
        def gds_encode(instring):
            if sys.version_info.major == 2:
                if ExternalEncoding:
                    encoding = ExternalEncoding
                else:
                    encoding = 'utf-8'
                return instring.encode(encoding)
            else:
                return instring
        @staticmethod
        def convert_unicode(instring):
            if isinstance(instring, str):
                result = quote_xml(instring)
            elif sys.version_info.major == 2 and isinstance(instring, unicode):
                result = quote_xml(instring).encode('utf8')
            else:
                result = GeneratedsSuper.gds_encode(str(instring))
            return result
        def __eq__(self, other):
            if type(self) != type(other):
                return False
            return self.__dict__ == other.__dict__
        def __ne__(self, other):
            return not self.__eq__(other)
    
    def getSubclassFromModule_(module, class_):
        '''Get the subclass of a class from a specific module.'''
        name = class_.__name__ + 'Sub'
        if hasattr(module, name):
            return getattr(module, name)
        else:
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = ''
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

# Change this to redirect the generated superclass module to use a
# specific subclass module.
CurrentSubclassModule_ = None

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, BaseStrType_) and inStr or '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace,
               pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(
                outfile, level, namespace, name,
                pretty_print=pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name,
                base64.b64encode(self.value),
                self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(
                element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type,
                    self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0,
            optional=0, child_attrs=None, choice=None):
        self.name = name
        self.data_type = data_type
        self.container = container
        self.child_attrs = child_attrs
        self.choice = choice
        self.optional = optional
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container
    def set_child_attrs(self, child_attrs): self.child_attrs = child_attrs
    def get_child_attrs(self): return self.child_attrs
    def set_choice(self, choice): self.choice = choice
    def get_choice(self): return self.choice
    def set_optional(self, optional): self.optional = optional
    def get_optional(self): return self.optional


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class emails(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, elementCount=None, email=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.elementCount = _cast(int, elementCount)
        if email is None:
            self.email = []
        else:
            self.email = email
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emails)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emails.subclass:
            return emails.subclass(*args_, **kwargs_)
        else:
            return emails(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_email(self): return self.email
    def set_email(self, email): self.email = email
    def add_email(self, value): self.email.append(value)
    def insert_email_at(self, index, value): self.email.insert(index, value)
    def replace_email_at(self, index, value): self.email[index] = value
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_elementCount(self): return self.elementCount
    def set_elementCount(self, elementCount): self.elementCount = elementCount
    def hasContent_(self):
        if (
            self.email
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='emails', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('emails')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='emails')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='emails', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='emails'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
        if self.elementCount is not None and 'elementCount' not in already_processed:
            already_processed.add('elementCount')
            outfile.write(' elementCount="%s"' % self.gds_format_integer(self.elementCount, input_name='elementCount'))
    def exportChildren(self, outfile, level, namespace_='', name_='emails', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for email_ in self.email:
            email_.export(outfile, level, namespace_, name_='email', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
        value = find_attr_value_('elementCount', node)
        if value is not None and 'elementCount' not in already_processed:
            already_processed.add('elementCount')
            try:
                self.elementCount = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'email':
            obj_ = emailType.factory()
            obj_.build(child_)
            self.email.append(obj_)
            obj_.original_tagname_ = 'email'
# end class emails


class emailAddress(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, OPFContactEmailAddressAddress=None, OPFContactEmailAddressName=None, OPFContactEmailAddressType=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.OPFContactEmailAddressAddress = _cast(None, OPFContactEmailAddressAddress)
        self.OPFContactEmailAddressName = _cast(None, OPFContactEmailAddressName)
        self.OPFContactEmailAddressType = _cast(int, OPFContactEmailAddressType)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emailAddress)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emailAddress.subclass:
            return emailAddress.subclass(*args_, **kwargs_)
        else:
            return emailAddress(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_OPFContactEmailAddressAddress(self): return self.OPFContactEmailAddressAddress
    def set_OPFContactEmailAddressAddress(self, OPFContactEmailAddressAddress): self.OPFContactEmailAddressAddress = OPFContactEmailAddressAddress
    def get_OPFContactEmailAddressName(self): return self.OPFContactEmailAddressName
    def set_OPFContactEmailAddressName(self, OPFContactEmailAddressName): self.OPFContactEmailAddressName = OPFContactEmailAddressName
    def get_OPFContactEmailAddressType(self): return self.OPFContactEmailAddressType
    def set_OPFContactEmailAddressType(self, OPFContactEmailAddressType): self.OPFContactEmailAddressType = OPFContactEmailAddressType
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='emailAddress', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('emailAddress')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='emailAddress')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='emailAddress', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='emailAddress'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
        if self.OPFContactEmailAddressAddress is not None and 'OPFContactEmailAddressAddress' not in already_processed:
            already_processed.add('OPFContactEmailAddressAddress')
            outfile.write(' OPFContactEmailAddressAddress=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OPFContactEmailAddressAddress), input_name='OPFContactEmailAddressAddress')), ))
        if self.OPFContactEmailAddressName is not None and 'OPFContactEmailAddressName' not in already_processed:
            already_processed.add('OPFContactEmailAddressName')
            outfile.write(' OPFContactEmailAddressName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OPFContactEmailAddressName), input_name='OPFContactEmailAddressName')), ))
        if self.OPFContactEmailAddressType is not None and 'OPFContactEmailAddressType' not in already_processed:
            already_processed.add('OPFContactEmailAddressType')
            outfile.write(' OPFContactEmailAddressType="%s"' % self.gds_format_integer(self.OPFContactEmailAddressType, input_name='OPFContactEmailAddressType'))
    def exportChildren(self, outfile, level, namespace_='', name_='emailAddress', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
        value = find_attr_value_('OPFContactEmailAddressAddress', node)
        if value is not None and 'OPFContactEmailAddressAddress' not in already_processed:
            already_processed.add('OPFContactEmailAddressAddress')
            self.OPFContactEmailAddressAddress = value
        value = find_attr_value_('OPFContactEmailAddressName', node)
        if value is not None and 'OPFContactEmailAddressName' not in already_processed:
            already_processed.add('OPFContactEmailAddressName')
            self.OPFContactEmailAddressName = value
        value = find_attr_value_('OPFContactEmailAddressType', node)
        if value is not None and 'OPFContactEmailAddressType' not in already_processed:
            already_processed.add('OPFContactEmailAddressType')
            try:
                self.OPFContactEmailAddressType = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class emailAddress


class emailType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, OPFMessageCopyPrimaryCategory=None, OPFMessageCopyCategoryList=None, OPFMessageCopyMeetingData=None, OPFMessageCopyReferences=None, OPFMessageCopyInReplyTo=None, OPFMessageCopyBCCAddresses=None, OPFMessageCopyReplyToAddresses=None, OPFMessageCopySenderAddress=None, OPFMessageCopyToAddresses=None, OPFMessageCopyThreadTopic=None, OPFMessageCopyCompletedDateTime=None, OPFMessageCopyDueDateTime=None, OPFMessageCopyStartDateTime=None, OPFMessageCopyModDate=None, OPFMessageCopySentTime=None, OPFMessageCopyThreadIndex=None, OPFMessageCopyReminderDateTime=None, OPFMessageCopyReceivedRepresentingName=None, OPFMessageCopyReceivedTime=None, OPFMessageGetCalendarAcceptStatus=None, OPFMessageGetSendReadReceipt=None, OPFMessageGetMentionedMe=None, OPFMessageGetInferenceClassification=None, OPFMessageGetHasRichText=None, OPFMessageGetIsRead=None, OPFMessageGetOverrideEncoding=None, OPFMessageGetPriority=None, OPFMessageCopySubject=None, OPFMessageCopySource=None, OPFMessageCopyGetFlagStatus=None, OPFMessageGetWasSent=None, OPFMessageIsCalendarMessage=None, OPFMessageIsMeeting=None, OPFMessageIsOutgoing=None, OPFMessageIsOutgoingMeetingResponse=None, OPFMessageCopyMessageID=None, OPFMessageGetHasHTML=None, OPFMessageCopyBody=None, OPFMessageCopyHTMLBody=None, OPFMessageCopyFromAddresses=None, OPFMessageCopyCCAddresses=None, OPFMessageCopyAttachmentList=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.OPFMessageCopyPrimaryCategory = OPFMessageCopyPrimaryCategory
        self.OPFMessageCopyCategoryList = OPFMessageCopyCategoryList
        self.OPFMessageCopyMeetingData = OPFMessageCopyMeetingData
        self.OPFMessageCopyReferences = OPFMessageCopyReferences
        self.OPFMessageCopyInReplyTo = OPFMessageCopyInReplyTo
        self.OPFMessageCopyBCCAddresses = OPFMessageCopyBCCAddresses
        self.OPFMessageCopyReplyToAddresses = OPFMessageCopyReplyToAddresses
        self.OPFMessageCopySenderAddress = OPFMessageCopySenderAddress
        self.OPFMessageCopyToAddresses = OPFMessageCopyToAddresses
        self.OPFMessageCopyThreadTopic = OPFMessageCopyThreadTopic
        self.OPFMessageCopyCompletedDateTime = OPFMessageCopyCompletedDateTime
        self.OPFMessageCopyDueDateTime = OPFMessageCopyDueDateTime
        self.OPFMessageCopyStartDateTime = OPFMessageCopyStartDateTime
        self.OPFMessageCopyModDate = OPFMessageCopyModDate
        self.OPFMessageCopySentTime = OPFMessageCopySentTime
        self.OPFMessageCopyThreadIndex = OPFMessageCopyThreadIndex
        self.OPFMessageCopyReminderDateTime = OPFMessageCopyReminderDateTime
        self.OPFMessageCopyReceivedRepresentingName = OPFMessageCopyReceivedRepresentingName
        self.OPFMessageCopyReceivedTime = OPFMessageCopyReceivedTime
        self.OPFMessageGetCalendarAcceptStatus = OPFMessageGetCalendarAcceptStatus
        self.OPFMessageGetSendReadReceipt = OPFMessageGetSendReadReceipt
        self.OPFMessageGetMentionedMe = OPFMessageGetMentionedMe
        self.OPFMessageGetInferenceClassification = OPFMessageGetInferenceClassification
        self.OPFMessageGetHasRichText = OPFMessageGetHasRichText
        self.OPFMessageGetIsRead = OPFMessageGetIsRead
        self.OPFMessageGetOverrideEncoding = OPFMessageGetOverrideEncoding
        self.OPFMessageGetPriority = OPFMessageGetPriority
        self.OPFMessageCopySubject = OPFMessageCopySubject
        self.OPFMessageCopySource = OPFMessageCopySource
        self.OPFMessageCopyGetFlagStatus = OPFMessageCopyGetFlagStatus
        self.OPFMessageGetWasSent = OPFMessageGetWasSent
        self.OPFMessageIsCalendarMessage = OPFMessageIsCalendarMessage
        self.OPFMessageIsMeeting = OPFMessageIsMeeting
        self.OPFMessageIsOutgoing = OPFMessageIsOutgoing
        self.OPFMessageIsOutgoingMeetingResponse = OPFMessageIsOutgoingMeetingResponse
        self.OPFMessageCopyMessageID = OPFMessageCopyMessageID
        self.OPFMessageGetHasHTML = OPFMessageGetHasHTML
        self.OPFMessageCopyBody = OPFMessageCopyBody
        self.OPFMessageCopyHTMLBody = OPFMessageCopyHTMLBody
        self.OPFMessageCopyFromAddresses = OPFMessageCopyFromAddresses
        self.OPFMessageCopyCCAddresses = OPFMessageCopyCCAddresses
        self.OPFMessageCopyAttachmentList = OPFMessageCopyAttachmentList
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, emailType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if emailType.subclass:
            return emailType.subclass(*args_, **kwargs_)
        else:
            return emailType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OPFMessageCopyPrimaryCategory(self): return self.OPFMessageCopyPrimaryCategory
    def set_OPFMessageCopyPrimaryCategory(self, OPFMessageCopyPrimaryCategory): self.OPFMessageCopyPrimaryCategory = OPFMessageCopyPrimaryCategory
    def get_OPFMessageCopyCategoryList(self): return self.OPFMessageCopyCategoryList
    def set_OPFMessageCopyCategoryList(self, OPFMessageCopyCategoryList): self.OPFMessageCopyCategoryList = OPFMessageCopyCategoryList
    def get_OPFMessageCopyMeetingData(self): return self.OPFMessageCopyMeetingData
    def set_OPFMessageCopyMeetingData(self, OPFMessageCopyMeetingData): self.OPFMessageCopyMeetingData = OPFMessageCopyMeetingData
    def get_OPFMessageCopyReferences(self): return self.OPFMessageCopyReferences
    def set_OPFMessageCopyReferences(self, OPFMessageCopyReferences): self.OPFMessageCopyReferences = OPFMessageCopyReferences
    def get_OPFMessageCopyInReplyTo(self): return self.OPFMessageCopyInReplyTo
    def set_OPFMessageCopyInReplyTo(self, OPFMessageCopyInReplyTo): self.OPFMessageCopyInReplyTo = OPFMessageCopyInReplyTo
    def get_OPFMessageCopyBCCAddresses(self): return self.OPFMessageCopyBCCAddresses
    def set_OPFMessageCopyBCCAddresses(self, OPFMessageCopyBCCAddresses): self.OPFMessageCopyBCCAddresses = OPFMessageCopyBCCAddresses
    def get_OPFMessageCopyReplyToAddresses(self): return self.OPFMessageCopyReplyToAddresses
    def set_OPFMessageCopyReplyToAddresses(self, OPFMessageCopyReplyToAddresses): self.OPFMessageCopyReplyToAddresses = OPFMessageCopyReplyToAddresses
    def get_OPFMessageCopySenderAddress(self): return self.OPFMessageCopySenderAddress
    def set_OPFMessageCopySenderAddress(self, OPFMessageCopySenderAddress): self.OPFMessageCopySenderAddress = OPFMessageCopySenderAddress
    def get_OPFMessageCopyToAddresses(self): return self.OPFMessageCopyToAddresses
    def set_OPFMessageCopyToAddresses(self, OPFMessageCopyToAddresses): self.OPFMessageCopyToAddresses = OPFMessageCopyToAddresses
    def get_OPFMessageCopyThreadTopic(self): return self.OPFMessageCopyThreadTopic
    def set_OPFMessageCopyThreadTopic(self, OPFMessageCopyThreadTopic): self.OPFMessageCopyThreadTopic = OPFMessageCopyThreadTopic
    def get_OPFMessageCopyCompletedDateTime(self): return self.OPFMessageCopyCompletedDateTime
    def set_OPFMessageCopyCompletedDateTime(self, OPFMessageCopyCompletedDateTime): self.OPFMessageCopyCompletedDateTime = OPFMessageCopyCompletedDateTime
    def get_OPFMessageCopyDueDateTime(self): return self.OPFMessageCopyDueDateTime
    def set_OPFMessageCopyDueDateTime(self, OPFMessageCopyDueDateTime): self.OPFMessageCopyDueDateTime = OPFMessageCopyDueDateTime
    def get_OPFMessageCopyStartDateTime(self): return self.OPFMessageCopyStartDateTime
    def set_OPFMessageCopyStartDateTime(self, OPFMessageCopyStartDateTime): self.OPFMessageCopyStartDateTime = OPFMessageCopyStartDateTime
    def get_OPFMessageCopyModDate(self): return self.OPFMessageCopyModDate
    def set_OPFMessageCopyModDate(self, OPFMessageCopyModDate): self.OPFMessageCopyModDate = OPFMessageCopyModDate
    def get_OPFMessageCopySentTime(self): return self.OPFMessageCopySentTime
    def set_OPFMessageCopySentTime(self, OPFMessageCopySentTime): self.OPFMessageCopySentTime = OPFMessageCopySentTime
    def get_OPFMessageCopyThreadIndex(self): return self.OPFMessageCopyThreadIndex
    def set_OPFMessageCopyThreadIndex(self, OPFMessageCopyThreadIndex): self.OPFMessageCopyThreadIndex = OPFMessageCopyThreadIndex
    def get_OPFMessageCopyReminderDateTime(self): return self.OPFMessageCopyReminderDateTime
    def set_OPFMessageCopyReminderDateTime(self, OPFMessageCopyReminderDateTime): self.OPFMessageCopyReminderDateTime = OPFMessageCopyReminderDateTime
    def get_OPFMessageCopyReceivedRepresentingName(self): return self.OPFMessageCopyReceivedRepresentingName
    def set_OPFMessageCopyReceivedRepresentingName(self, OPFMessageCopyReceivedRepresentingName): self.OPFMessageCopyReceivedRepresentingName = OPFMessageCopyReceivedRepresentingName
    def get_OPFMessageCopyReceivedTime(self): return self.OPFMessageCopyReceivedTime
    def set_OPFMessageCopyReceivedTime(self, OPFMessageCopyReceivedTime): self.OPFMessageCopyReceivedTime = OPFMessageCopyReceivedTime
    def get_OPFMessageGetCalendarAcceptStatus(self): return self.OPFMessageGetCalendarAcceptStatus
    def set_OPFMessageGetCalendarAcceptStatus(self, OPFMessageGetCalendarAcceptStatus): self.OPFMessageGetCalendarAcceptStatus = OPFMessageGetCalendarAcceptStatus
    def get_OPFMessageGetSendReadReceipt(self): return self.OPFMessageGetSendReadReceipt
    def set_OPFMessageGetSendReadReceipt(self, OPFMessageGetSendReadReceipt): self.OPFMessageGetSendReadReceipt = OPFMessageGetSendReadReceipt
    def get_OPFMessageGetMentionedMe(self): return self.OPFMessageGetMentionedMe
    def set_OPFMessageGetMentionedMe(self, OPFMessageGetMentionedMe): self.OPFMessageGetMentionedMe = OPFMessageGetMentionedMe
    def get_OPFMessageGetInferenceClassification(self): return self.OPFMessageGetInferenceClassification
    def set_OPFMessageGetInferenceClassification(self, OPFMessageGetInferenceClassification): self.OPFMessageGetInferenceClassification = OPFMessageGetInferenceClassification
    def get_OPFMessageGetHasRichText(self): return self.OPFMessageGetHasRichText
    def set_OPFMessageGetHasRichText(self, OPFMessageGetHasRichText): self.OPFMessageGetHasRichText = OPFMessageGetHasRichText
    def get_OPFMessageGetIsRead(self): return self.OPFMessageGetIsRead
    def set_OPFMessageGetIsRead(self, OPFMessageGetIsRead): self.OPFMessageGetIsRead = OPFMessageGetIsRead
    def get_OPFMessageGetOverrideEncoding(self): return self.OPFMessageGetOverrideEncoding
    def set_OPFMessageGetOverrideEncoding(self, OPFMessageGetOverrideEncoding): self.OPFMessageGetOverrideEncoding = OPFMessageGetOverrideEncoding
    def get_OPFMessageGetPriority(self): return self.OPFMessageGetPriority
    def set_OPFMessageGetPriority(self, OPFMessageGetPriority): self.OPFMessageGetPriority = OPFMessageGetPriority
    def get_OPFMessageCopySubject(self): return self.OPFMessageCopySubject
    def set_OPFMessageCopySubject(self, OPFMessageCopySubject): self.OPFMessageCopySubject = OPFMessageCopySubject
    def get_OPFMessageCopySource(self): return self.OPFMessageCopySource
    def set_OPFMessageCopySource(self, OPFMessageCopySource): self.OPFMessageCopySource = OPFMessageCopySource
    def get_OPFMessageCopyGetFlagStatus(self): return self.OPFMessageCopyGetFlagStatus
    def set_OPFMessageCopyGetFlagStatus(self, OPFMessageCopyGetFlagStatus): self.OPFMessageCopyGetFlagStatus = OPFMessageCopyGetFlagStatus
    def get_OPFMessageGetWasSent(self): return self.OPFMessageGetWasSent
    def set_OPFMessageGetWasSent(self, OPFMessageGetWasSent): self.OPFMessageGetWasSent = OPFMessageGetWasSent
    def get_OPFMessageIsCalendarMessage(self): return self.OPFMessageIsCalendarMessage
    def set_OPFMessageIsCalendarMessage(self, OPFMessageIsCalendarMessage): self.OPFMessageIsCalendarMessage = OPFMessageIsCalendarMessage
    def get_OPFMessageIsMeeting(self): return self.OPFMessageIsMeeting
    def set_OPFMessageIsMeeting(self, OPFMessageIsMeeting): self.OPFMessageIsMeeting = OPFMessageIsMeeting
    def get_OPFMessageIsOutgoing(self): return self.OPFMessageIsOutgoing
    def set_OPFMessageIsOutgoing(self, OPFMessageIsOutgoing): self.OPFMessageIsOutgoing = OPFMessageIsOutgoing
    def get_OPFMessageIsOutgoingMeetingResponse(self): return self.OPFMessageIsOutgoingMeetingResponse
    def set_OPFMessageIsOutgoingMeetingResponse(self, OPFMessageIsOutgoingMeetingResponse): self.OPFMessageIsOutgoingMeetingResponse = OPFMessageIsOutgoingMeetingResponse
    def get_OPFMessageCopyMessageID(self): return self.OPFMessageCopyMessageID
    def set_OPFMessageCopyMessageID(self, OPFMessageCopyMessageID): self.OPFMessageCopyMessageID = OPFMessageCopyMessageID
    def get_OPFMessageGetHasHTML(self): return self.OPFMessageGetHasHTML
    def set_OPFMessageGetHasHTML(self, OPFMessageGetHasHTML): self.OPFMessageGetHasHTML = OPFMessageGetHasHTML
    def get_OPFMessageCopyBody(self): return self.OPFMessageCopyBody
    def set_OPFMessageCopyBody(self, OPFMessageCopyBody): self.OPFMessageCopyBody = OPFMessageCopyBody
    def get_OPFMessageCopyHTMLBody(self): return self.OPFMessageCopyHTMLBody
    def set_OPFMessageCopyHTMLBody(self, OPFMessageCopyHTMLBody): self.OPFMessageCopyHTMLBody = OPFMessageCopyHTMLBody
    def get_OPFMessageCopyFromAddresses(self): return self.OPFMessageCopyFromAddresses
    def set_OPFMessageCopyFromAddresses(self, OPFMessageCopyFromAddresses): self.OPFMessageCopyFromAddresses = OPFMessageCopyFromAddresses
    def get_OPFMessageCopyCCAddresses(self): return self.OPFMessageCopyCCAddresses
    def set_OPFMessageCopyCCAddresses(self, OPFMessageCopyCCAddresses): self.OPFMessageCopyCCAddresses = OPFMessageCopyCCAddresses
    def get_OPFMessageCopyAttachmentList(self): return self.OPFMessageCopyAttachmentList
    def set_OPFMessageCopyAttachmentList(self, OPFMessageCopyAttachmentList): self.OPFMessageCopyAttachmentList = OPFMessageCopyAttachmentList
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def hasContent_(self):
        if (
            self.OPFMessageCopyPrimaryCategory is not None or
            self.OPFMessageCopyCategoryList is not None or
            self.OPFMessageCopyMeetingData is not None or
            self.OPFMessageCopyReferences is not None or
            self.OPFMessageCopyInReplyTo is not None or
            self.OPFMessageCopyBCCAddresses is not None or
            self.OPFMessageCopyReplyToAddresses is not None or
            self.OPFMessageCopySenderAddress is not None or
            self.OPFMessageCopyToAddresses is not None or
            self.OPFMessageCopyThreadTopic is not None or
            self.OPFMessageCopyCompletedDateTime is not None or
            self.OPFMessageCopyDueDateTime is not None or
            self.OPFMessageCopyStartDateTime is not None or
            self.OPFMessageCopyModDate is not None or
            self.OPFMessageCopySentTime is not None or
            self.OPFMessageCopyThreadIndex is not None or
            self.OPFMessageCopyReminderDateTime is not None or
            self.OPFMessageCopyReceivedRepresentingName is not None or
            self.OPFMessageCopyReceivedTime is not None or
            self.OPFMessageGetCalendarAcceptStatus is not None or
            self.OPFMessageGetSendReadReceipt is not None or
            self.OPFMessageGetMentionedMe is not None or
            self.OPFMessageGetInferenceClassification is not None or
            self.OPFMessageGetHasRichText is not None or
            self.OPFMessageGetIsRead is not None or
            self.OPFMessageGetOverrideEncoding is not None or
            self.OPFMessageGetPriority is not None or
            self.OPFMessageCopySubject is not None or
            self.OPFMessageCopySource is not None or
            self.OPFMessageCopyGetFlagStatus is not None or
            self.OPFMessageGetWasSent is not None or
            self.OPFMessageIsCalendarMessage is not None or
            self.OPFMessageIsMeeting is not None or
            self.OPFMessageIsOutgoing is not None or
            self.OPFMessageIsOutgoingMeetingResponse is not None or
            self.OPFMessageCopyMessageID is not None or
            self.OPFMessageGetHasHTML is not None or
            self.OPFMessageCopyBody is not None or
            self.OPFMessageCopyHTMLBody is not None or
            self.OPFMessageCopyFromAddresses is not None or
            self.OPFMessageCopyCCAddresses is not None or
            self.OPFMessageCopyAttachmentList is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='emailType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('emailType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='emailType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='emailType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='emailType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='emailType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OPFMessageCopyPrimaryCategory is not None:
            self.OPFMessageCopyPrimaryCategory.export(outfile, level, namespace_, name_='OPFMessageCopyPrimaryCategory', pretty_print=pretty_print)
        if self.OPFMessageCopyCategoryList is not None:
            self.OPFMessageCopyCategoryList.export(outfile, level, namespace_, name_='OPFMessageCopyCategoryList', pretty_print=pretty_print)
        if self.OPFMessageCopyMeetingData is not None:
            self.OPFMessageCopyMeetingData.export(outfile, level, namespace_, name_='OPFMessageCopyMeetingData', pretty_print=pretty_print)
        if self.OPFMessageCopyReferences is not None:
            self.OPFMessageCopyReferences.export(outfile, level, namespace_, name_='OPFMessageCopyReferences', pretty_print=pretty_print)
        if self.OPFMessageCopyInReplyTo is not None:
            self.OPFMessageCopyInReplyTo.export(outfile, level, namespace_, name_='OPFMessageCopyInReplyTo', pretty_print=pretty_print)
        if self.OPFMessageCopyBCCAddresses is not None:
            self.OPFMessageCopyBCCAddresses.export(outfile, level, namespace_, name_='OPFMessageCopyBCCAddresses', pretty_print=pretty_print)
        if self.OPFMessageCopyReplyToAddresses is not None:
            self.OPFMessageCopyReplyToAddresses.export(outfile, level, namespace_, name_='OPFMessageCopyReplyToAddresses', pretty_print=pretty_print)
        if self.OPFMessageCopySenderAddress is not None:
            self.OPFMessageCopySenderAddress.export(outfile, level, namespace_, name_='OPFMessageCopySenderAddress', pretty_print=pretty_print)
        if self.OPFMessageCopyToAddresses is not None:
            self.OPFMessageCopyToAddresses.export(outfile, level, namespace_, name_='OPFMessageCopyToAddresses', pretty_print=pretty_print)
        if self.OPFMessageCopyThreadTopic is not None:
            self.OPFMessageCopyThreadTopic.export(outfile, level, namespace_, name_='OPFMessageCopyThreadTopic', pretty_print=pretty_print)
        if self.OPFMessageCopyCompletedDateTime is not None:
            self.OPFMessageCopyCompletedDateTime.export(outfile, level, namespace_, name_='OPFMessageCopyCompletedDateTime', pretty_print=pretty_print)
        if self.OPFMessageCopyDueDateTime is not None:
            self.OPFMessageCopyDueDateTime.export(outfile, level, namespace_, name_='OPFMessageCopyDueDateTime', pretty_print=pretty_print)
        if self.OPFMessageCopyStartDateTime is not None:
            self.OPFMessageCopyStartDateTime.export(outfile, level, namespace_, name_='OPFMessageCopyStartDateTime', pretty_print=pretty_print)
        if self.OPFMessageCopyModDate is not None:
            self.OPFMessageCopyModDate.export(outfile, level, namespace_, name_='OPFMessageCopyModDate', pretty_print=pretty_print)
        if self.OPFMessageCopySentTime is not None:
            self.OPFMessageCopySentTime.export(outfile, level, namespace_, name_='OPFMessageCopySentTime', pretty_print=pretty_print)
        if self.OPFMessageCopyThreadIndex is not None:
            self.OPFMessageCopyThreadIndex.export(outfile, level, namespace_, name_='OPFMessageCopyThreadIndex', pretty_print=pretty_print)
        if self.OPFMessageCopyReminderDateTime is not None:
            self.OPFMessageCopyReminderDateTime.export(outfile, level, namespace_, name_='OPFMessageCopyReminderDateTime', pretty_print=pretty_print)
        if self.OPFMessageCopyReceivedRepresentingName is not None:
            self.OPFMessageCopyReceivedRepresentingName.export(outfile, level, namespace_, name_='OPFMessageCopyReceivedRepresentingName', pretty_print=pretty_print)
        if self.OPFMessageCopyReceivedTime is not None:
            self.OPFMessageCopyReceivedTime.export(outfile, level, namespace_, name_='OPFMessageCopyReceivedTime', pretty_print=pretty_print)
        if self.OPFMessageGetCalendarAcceptStatus is not None:
            self.OPFMessageGetCalendarAcceptStatus.export(outfile, level, namespace_, name_='OPFMessageGetCalendarAcceptStatus', pretty_print=pretty_print)
        if self.OPFMessageGetSendReadReceipt is not None:
            self.OPFMessageGetSendReadReceipt.export(outfile, level, namespace_, name_='OPFMessageGetSendReadReceipt', pretty_print=pretty_print)
        if self.OPFMessageGetMentionedMe is not None:
            self.OPFMessageGetMentionedMe.export(outfile, level, namespace_, name_='OPFMessageGetMentionedMe', pretty_print=pretty_print)
        if self.OPFMessageGetInferenceClassification is not None:
            self.OPFMessageGetInferenceClassification.export(outfile, level, namespace_, name_='OPFMessageGetInferenceClassification', pretty_print=pretty_print)
        if self.OPFMessageGetHasRichText is not None:
            self.OPFMessageGetHasRichText.export(outfile, level, namespace_, name_='OPFMessageGetHasRichText', pretty_print=pretty_print)
        if self.OPFMessageGetIsRead is not None:
            self.OPFMessageGetIsRead.export(outfile, level, namespace_, name_='OPFMessageGetIsRead', pretty_print=pretty_print)
        if self.OPFMessageGetOverrideEncoding is not None:
            self.OPFMessageGetOverrideEncoding.export(outfile, level, namespace_, name_='OPFMessageGetOverrideEncoding', pretty_print=pretty_print)
        if self.OPFMessageGetPriority is not None:
            self.OPFMessageGetPriority.export(outfile, level, namespace_, name_='OPFMessageGetPriority', pretty_print=pretty_print)
        if self.OPFMessageCopySubject is not None:
            self.OPFMessageCopySubject.export(outfile, level, namespace_, name_='OPFMessageCopySubject', pretty_print=pretty_print)
        if self.OPFMessageCopySource is not None:
            self.OPFMessageCopySource.export(outfile, level, namespace_, name_='OPFMessageCopySource', pretty_print=pretty_print)
        if self.OPFMessageCopyGetFlagStatus is not None:
            self.OPFMessageCopyGetFlagStatus.export(outfile, level, namespace_, name_='OPFMessageCopyGetFlagStatus', pretty_print=pretty_print)
        if self.OPFMessageGetWasSent is not None:
            self.OPFMessageGetWasSent.export(outfile, level, namespace_, name_='OPFMessageGetWasSent', pretty_print=pretty_print)
        if self.OPFMessageIsCalendarMessage is not None:
            self.OPFMessageIsCalendarMessage.export(outfile, level, namespace_, name_='OPFMessageIsCalendarMessage', pretty_print=pretty_print)
        if self.OPFMessageIsMeeting is not None:
            self.OPFMessageIsMeeting.export(outfile, level, namespace_, name_='OPFMessageIsMeeting', pretty_print=pretty_print)
        if self.OPFMessageIsOutgoing is not None:
            self.OPFMessageIsOutgoing.export(outfile, level, namespace_, name_='OPFMessageIsOutgoing', pretty_print=pretty_print)
        if self.OPFMessageIsOutgoingMeetingResponse is not None:
            self.OPFMessageIsOutgoingMeetingResponse.export(outfile, level, namespace_, name_='OPFMessageIsOutgoingMeetingResponse', pretty_print=pretty_print)
        if self.OPFMessageCopyMessageID is not None:
            self.OPFMessageCopyMessageID.export(outfile, level, namespace_, name_='OPFMessageCopyMessageID', pretty_print=pretty_print)
        if self.OPFMessageGetHasHTML is not None:
            self.OPFMessageGetHasHTML.export(outfile, level, namespace_, name_='OPFMessageGetHasHTML', pretty_print=pretty_print)
        if self.OPFMessageCopyBody is not None:
            self.OPFMessageCopyBody.export(outfile, level, namespace_, name_='OPFMessageCopyBody', pretty_print=pretty_print)
        if self.OPFMessageCopyHTMLBody is not None:
            self.OPFMessageCopyHTMLBody.export(outfile, level, namespace_, name_='OPFMessageCopyHTMLBody', pretty_print=pretty_print)
        if self.OPFMessageCopyFromAddresses is not None:
            self.OPFMessageCopyFromAddresses.export(outfile, level, namespace_, name_='OPFMessageCopyFromAddresses', pretty_print=pretty_print)
        if self.OPFMessageCopyCCAddresses is not None:
            self.OPFMessageCopyCCAddresses.export(outfile, level, namespace_, name_='OPFMessageCopyCCAddresses', pretty_print=pretty_print)
        if self.OPFMessageCopyAttachmentList is not None:
            self.OPFMessageCopyAttachmentList.export(outfile, level, namespace_, name_='OPFMessageCopyAttachmentList', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OPFMessageCopyPrimaryCategory':
            obj_ = OPFMessageCopyPrimaryCategoryType.factory()
            obj_.build(child_)
            self.OPFMessageCopyPrimaryCategory = obj_
            obj_.original_tagname_ = 'OPFMessageCopyPrimaryCategory'
        elif nodeName_ == 'OPFMessageCopyCategoryList':
            obj_ = OPFMessageCopyCategoryListType.factory()
            obj_.build(child_)
            self.OPFMessageCopyCategoryList = obj_
            obj_.original_tagname_ = 'OPFMessageCopyCategoryList'
        elif nodeName_ == 'OPFMessageCopyMeetingData':
            obj_ = OPFMessageCopyMeetingDataType.factory()
            obj_.build(child_)
            self.OPFMessageCopyMeetingData = obj_
            obj_.original_tagname_ = 'OPFMessageCopyMeetingData'
        elif nodeName_ == 'OPFMessageCopyReferences':
            obj_ = OPFMessageCopyReferencesType.factory()
            obj_.build(child_)
            self.OPFMessageCopyReferences = obj_
            obj_.original_tagname_ = 'OPFMessageCopyReferences'
        elif nodeName_ == 'OPFMessageCopyInReplyTo':
            obj_ = OPFMessageCopyInReplyToType.factory()
            obj_.build(child_)
            self.OPFMessageCopyInReplyTo = obj_
            obj_.original_tagname_ = 'OPFMessageCopyInReplyTo'
        elif nodeName_ == 'OPFMessageCopyBCCAddresses':
            obj_ = OPFMessageCopyBCCAddressesType.factory()
            obj_.build(child_)
            self.OPFMessageCopyBCCAddresses = obj_
            obj_.original_tagname_ = 'OPFMessageCopyBCCAddresses'
        elif nodeName_ == 'OPFMessageCopyReplyToAddresses':
            obj_ = OPFMessageCopyReplyToAddressesType.factory()
            obj_.build(child_)
            self.OPFMessageCopyReplyToAddresses = obj_
            obj_.original_tagname_ = 'OPFMessageCopyReplyToAddresses'
        elif nodeName_ == 'OPFMessageCopySenderAddress':
            obj_ = OPFMessageCopySenderAddressType.factory()
            obj_.build(child_)
            self.OPFMessageCopySenderAddress = obj_
            obj_.original_tagname_ = 'OPFMessageCopySenderAddress'
        elif nodeName_ == 'OPFMessageCopyToAddresses':
            obj_ = OPFMessageCopyToAddressesType.factory()
            obj_.build(child_)
            self.OPFMessageCopyToAddresses = obj_
            obj_.original_tagname_ = 'OPFMessageCopyToAddresses'
        elif nodeName_ == 'OPFMessageCopyThreadTopic':
            obj_ = OPFMessageCopyThreadTopicType.factory()
            obj_.build(child_)
            self.OPFMessageCopyThreadTopic = obj_
            obj_.original_tagname_ = 'OPFMessageCopyThreadTopic'
        elif nodeName_ == 'OPFMessageCopyCompletedDateTime':
            obj_ = OPFMessageCopyCompletedDateTimeType.factory()
            obj_.build(child_)
            self.OPFMessageCopyCompletedDateTime = obj_
            obj_.original_tagname_ = 'OPFMessageCopyCompletedDateTime'
        elif nodeName_ == 'OPFMessageCopyDueDateTime':
            obj_ = OPFMessageCopyDueDateTimeType.factory()
            obj_.build(child_)
            self.OPFMessageCopyDueDateTime = obj_
            obj_.original_tagname_ = 'OPFMessageCopyDueDateTime'
        elif nodeName_ == 'OPFMessageCopyStartDateTime':
            obj_ = OPFMessageCopyStartDateTimeType.factory()
            obj_.build(child_)
            self.OPFMessageCopyStartDateTime = obj_
            obj_.original_tagname_ = 'OPFMessageCopyStartDateTime'
        elif nodeName_ == 'OPFMessageCopyModDate':
            obj_ = OPFMessageCopyModDateType.factory()
            obj_.build(child_)
            self.OPFMessageCopyModDate = obj_
            obj_.original_tagname_ = 'OPFMessageCopyModDate'
        elif nodeName_ == 'OPFMessageCopySentTime':
            obj_ = OPFMessageCopySentTimeType.factory()
            obj_.build(child_)
            self.OPFMessageCopySentTime = obj_
            obj_.original_tagname_ = 'OPFMessageCopySentTime'
        elif nodeName_ == 'OPFMessageCopyThreadIndex':
            obj_ = OPFMessageCopyThreadIndexType.factory()
            obj_.build(child_)
            self.OPFMessageCopyThreadIndex = obj_
            obj_.original_tagname_ = 'OPFMessageCopyThreadIndex'
        elif nodeName_ == 'OPFMessageCopyReminderDateTime':
            obj_ = OPFMessageCopyReminderDateTimeType.factory()
            obj_.build(child_)
            self.OPFMessageCopyReminderDateTime = obj_
            obj_.original_tagname_ = 'OPFMessageCopyReminderDateTime'
        elif nodeName_ == 'OPFMessageCopyReceivedRepresentingName':
            obj_ = OPFMessageCopyReceivedRepresentingNameType.factory()
            obj_.build(child_)
            self.OPFMessageCopyReceivedRepresentingName = obj_
            obj_.original_tagname_ = 'OPFMessageCopyReceivedRepresentingName'
        elif nodeName_ == 'OPFMessageCopyReceivedTime':
            obj_ = OPFMessageCopyReceivedTimeType.factory()
            obj_.build(child_)
            self.OPFMessageCopyReceivedTime = obj_
            obj_.original_tagname_ = 'OPFMessageCopyReceivedTime'
        elif nodeName_ == 'OPFMessageGetCalendarAcceptStatus':
            obj_ = OPFMessageGetCalendarAcceptStatusType.factory()
            obj_.build(child_)
            self.OPFMessageGetCalendarAcceptStatus = obj_
            obj_.original_tagname_ = 'OPFMessageGetCalendarAcceptStatus'
        elif nodeName_ == 'OPFMessageGetSendReadReceipt':
            obj_ = OPFMessageGetSendReadReceiptType.factory()
            obj_.build(child_)
            self.OPFMessageGetSendReadReceipt = obj_
            obj_.original_tagname_ = 'OPFMessageGetSendReadReceipt'
        elif nodeName_ == 'OPFMessageGetMentionedMe':
            obj_ = OPFMessageGetMentionedMeType.factory()
            obj_.build(child_)
            self.OPFMessageGetMentionedMe = obj_
            obj_.original_tagname_ = 'OPFMessageGetMentionedMe'
        elif nodeName_ == 'OPFMessageGetInferenceClassification':
            obj_ = OPFMessageGetInferenceClassificationType.factory()
            obj_.build(child_)
            self.OPFMessageGetInferenceClassification = obj_
            obj_.original_tagname_ = 'OPFMessageGetInferenceClassification'
        elif nodeName_ == 'OPFMessageGetHasRichText':
            obj_ = OPFMessageGetHasRichTextType.factory()
            obj_.build(child_)
            self.OPFMessageGetHasRichText = obj_
            obj_.original_tagname_ = 'OPFMessageGetHasRichText'
        elif nodeName_ == 'OPFMessageGetIsRead':
            obj_ = OPFMessageGetIsReadType.factory()
            obj_.build(child_)
            self.OPFMessageGetIsRead = obj_
            obj_.original_tagname_ = 'OPFMessageGetIsRead'
        elif nodeName_ == 'OPFMessageGetOverrideEncoding':
            obj_ = OPFMessageGetOverrideEncodingType.factory()
            obj_.build(child_)
            self.OPFMessageGetOverrideEncoding = obj_
            obj_.original_tagname_ = 'OPFMessageGetOverrideEncoding'
        elif nodeName_ == 'OPFMessageGetPriority':
            obj_ = OPFMessageGetPriorityType.factory()
            obj_.build(child_)
            self.OPFMessageGetPriority = obj_
            obj_.original_tagname_ = 'OPFMessageGetPriority'
        elif nodeName_ == 'OPFMessageCopySubject':
            obj_ = OPFMessageCopySubjectType.factory()
            obj_.build(child_)
            self.OPFMessageCopySubject = obj_
            obj_.original_tagname_ = 'OPFMessageCopySubject'
        elif nodeName_ == 'OPFMessageCopySource':
            obj_ = OPFMessageCopySourceType.factory()
            obj_.build(child_)
            self.OPFMessageCopySource = obj_
            obj_.original_tagname_ = 'OPFMessageCopySource'
        elif nodeName_ == 'OPFMessageCopyGetFlagStatus':
            obj_ = OPFMessageCopyGetFlagStatusType.factory()
            obj_.build(child_)
            self.OPFMessageCopyGetFlagStatus = obj_
            obj_.original_tagname_ = 'OPFMessageCopyGetFlagStatus'
        elif nodeName_ == 'OPFMessageGetWasSent':
            obj_ = OPFMessageGetWasSentType.factory()
            obj_.build(child_)
            self.OPFMessageGetWasSent = obj_
            obj_.original_tagname_ = 'OPFMessageGetWasSent'
        elif nodeName_ == 'OPFMessageIsCalendarMessage':
            obj_ = OPFMessageIsCalendarMessageType.factory()
            obj_.build(child_)
            self.OPFMessageIsCalendarMessage = obj_
            obj_.original_tagname_ = 'OPFMessageIsCalendarMessage'
        elif nodeName_ == 'OPFMessageIsMeeting':
            obj_ = OPFMessageIsMeetingType.factory()
            obj_.build(child_)
            self.OPFMessageIsMeeting = obj_
            obj_.original_tagname_ = 'OPFMessageIsMeeting'
        elif nodeName_ == 'OPFMessageIsOutgoing':
            obj_ = OPFMessageIsOutgoingType.factory()
            obj_.build(child_)
            self.OPFMessageIsOutgoing = obj_
            obj_.original_tagname_ = 'OPFMessageIsOutgoing'
        elif nodeName_ == 'OPFMessageIsOutgoingMeetingResponse':
            obj_ = OPFMessageIsOutgoingMeetingResponseType.factory()
            obj_.build(child_)
            self.OPFMessageIsOutgoingMeetingResponse = obj_
            obj_.original_tagname_ = 'OPFMessageIsOutgoingMeetingResponse'
        elif nodeName_ == 'OPFMessageCopyMessageID':
            obj_ = OPFMessageCopyMessageIDType.factory()
            obj_.build(child_)
            self.OPFMessageCopyMessageID = obj_
            obj_.original_tagname_ = 'OPFMessageCopyMessageID'
        elif nodeName_ == 'OPFMessageGetHasHTML':
            obj_ = OPFMessageGetHasHTMLType.factory()
            obj_.build(child_)
            self.OPFMessageGetHasHTML = obj_
            obj_.original_tagname_ = 'OPFMessageGetHasHTML'
        elif nodeName_ == 'OPFMessageCopyBody':
            obj_ = OPFMessageCopyBodyType.factory()
            obj_.build(child_)
            self.OPFMessageCopyBody = obj_
            obj_.original_tagname_ = 'OPFMessageCopyBody'
        elif nodeName_ == 'OPFMessageCopyHTMLBody':
            obj_ = OPFMessageCopyHTMLBodyType.factory()
            obj_.build(child_)
            self.OPFMessageCopyHTMLBody = obj_
            obj_.original_tagname_ = 'OPFMessageCopyHTMLBody'
        elif nodeName_ == 'OPFMessageCopyFromAddresses':
            obj_ = OPFMessageCopyFromAddressesType.factory()
            obj_.build(child_)
            self.OPFMessageCopyFromAddresses = obj_
            obj_.original_tagname_ = 'OPFMessageCopyFromAddresses'
        elif nodeName_ == 'OPFMessageCopyCCAddresses':
            obj_ = OPFMessageCopyCCAddressesType.factory()
            obj_.build(child_)
            self.OPFMessageCopyCCAddresses = obj_
            obj_.original_tagname_ = 'OPFMessageCopyCCAddresses'
        elif nodeName_ == 'OPFMessageCopyAttachmentList':
            obj_ = OPFMessageCopyAttachmentListType.factory()
            obj_.build(child_)
            self.OPFMessageCopyAttachmentList = obj_
            obj_.original_tagname_ = 'OPFMessageCopyAttachmentList'
# end class emailType


class OPFMessageCopyPrimaryCategoryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, OPFCategoryCopyBackgroundColor=None, OPFCategoryCopyName=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.OPFCategoryCopyBackgroundColor = OPFCategoryCopyBackgroundColor
        self.OPFCategoryCopyName = OPFCategoryCopyName
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyPrimaryCategoryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyPrimaryCategoryType.subclass:
            return OPFMessageCopyPrimaryCategoryType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyPrimaryCategoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OPFCategoryCopyBackgroundColor(self): return self.OPFCategoryCopyBackgroundColor
    def set_OPFCategoryCopyBackgroundColor(self, OPFCategoryCopyBackgroundColor): self.OPFCategoryCopyBackgroundColor = OPFCategoryCopyBackgroundColor
    def get_OPFCategoryCopyName(self): return self.OPFCategoryCopyName
    def set_OPFCategoryCopyName(self, OPFCategoryCopyName): self.OPFCategoryCopyName = OPFCategoryCopyName
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def hasContent_(self):
        if (
            self.OPFCategoryCopyBackgroundColor is not None or
            self.OPFCategoryCopyName is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyPrimaryCategoryType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyPrimaryCategoryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyPrimaryCategoryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyPrimaryCategoryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyPrimaryCategoryType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyPrimaryCategoryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.OPFCategoryCopyBackgroundColor is not None:
            self.OPFCategoryCopyBackgroundColor.export(outfile, level, namespace_, name_='OPFCategoryCopyBackgroundColor', pretty_print=pretty_print)
        if self.OPFCategoryCopyName is not None:
            self.OPFCategoryCopyName.export(outfile, level, namespace_, name_='OPFCategoryCopyName', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'OPFCategoryCopyBackgroundColor':
            obj_ = OPFCategoryCopyBackgroundColorType.factory()
            obj_.build(child_)
            self.OPFCategoryCopyBackgroundColor = obj_
            obj_.original_tagname_ = 'OPFCategoryCopyBackgroundColor'
        elif nodeName_ == 'OPFCategoryCopyName':
            obj_ = OPFCategoryCopyNameType.factory()
            obj_.build(child_)
            self.OPFCategoryCopyName = obj_
            obj_.original_tagname_ = 'OPFCategoryCopyName'
# end class OPFMessageCopyPrimaryCategoryType


class OPFCategoryCopyBackgroundColorType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFCategoryCopyBackgroundColorType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFCategoryCopyBackgroundColorType.subclass:
            return OPFCategoryCopyBackgroundColorType.subclass(*args_, **kwargs_)
        else:
            return OPFCategoryCopyBackgroundColorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFCategoryCopyBackgroundColorType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFCategoryCopyBackgroundColorType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFCategoryCopyBackgroundColorType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFCategoryCopyBackgroundColorType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFCategoryCopyBackgroundColorType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFCategoryCopyBackgroundColorType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFCategoryCopyBackgroundColorType


class OPFCategoryCopyNameType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFCategoryCopyNameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFCategoryCopyNameType.subclass:
            return OPFCategoryCopyNameType.subclass(*args_, **kwargs_)
        else:
            return OPFCategoryCopyNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFCategoryCopyNameType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFCategoryCopyNameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFCategoryCopyNameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFCategoryCopyNameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFCategoryCopyNameType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFCategoryCopyNameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFCategoryCopyNameType


class OPFMessageCopyCategoryListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, category=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        if category is None:
            self.category = []
        else:
            self.category = category
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyCategoryListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyCategoryListType.subclass:
            return OPFMessageCopyCategoryListType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyCategoryListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_category(self): return self.category
    def set_category(self, category): self.category = category
    def add_category(self, value): self.category.append(value)
    def insert_category_at(self, index, value): self.category.insert(index, value)
    def replace_category_at(self, index, value): self.category[index] = value
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def hasContent_(self):
        if (
            self.category
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyCategoryListType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyCategoryListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyCategoryListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyCategoryListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyCategoryListType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyCategoryListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for category_ in self.category:
            category_.export(outfile, level, namespace_, name_='category', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'category':
            obj_ = categoryType.factory()
            obj_.build(child_)
            self.category.append(obj_)
            obj_.original_tagname_ = 'category'
# end class OPFMessageCopyCategoryListType


class categoryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OPFCategoryCopyBackgroundColor=None, OPFCategoryCopyName=None, space=None):
        self.original_tagname_ = None
        self.OPFCategoryCopyBackgroundColor = _cast(None, OPFCategoryCopyBackgroundColor)
        self.OPFCategoryCopyName = _cast(None, OPFCategoryCopyName)
        self.space = _cast(None, space)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, categoryType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if categoryType.subclass:
            return categoryType.subclass(*args_, **kwargs_)
        else:
            return categoryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OPFCategoryCopyBackgroundColor(self): return self.OPFCategoryCopyBackgroundColor
    def set_OPFCategoryCopyBackgroundColor(self, OPFCategoryCopyBackgroundColor): self.OPFCategoryCopyBackgroundColor = OPFCategoryCopyBackgroundColor
    def get_OPFCategoryCopyName(self): return self.OPFCategoryCopyName
    def set_OPFCategoryCopyName(self, OPFCategoryCopyName): self.OPFCategoryCopyName = OPFCategoryCopyName
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='categoryType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('categoryType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='categoryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='categoryType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='categoryType'):
        if self.OPFCategoryCopyBackgroundColor is not None and 'OPFCategoryCopyBackgroundColor' not in already_processed:
            already_processed.add('OPFCategoryCopyBackgroundColor')
            outfile.write(' OPFCategoryCopyBackgroundColor=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OPFCategoryCopyBackgroundColor), input_name='OPFCategoryCopyBackgroundColor')), ))
        if self.OPFCategoryCopyName is not None and 'OPFCategoryCopyName' not in already_processed:
            already_processed.add('OPFCategoryCopyName')
            outfile.write(' OPFCategoryCopyName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OPFCategoryCopyName), input_name='OPFCategoryCopyName')), ))
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='categoryType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('OPFCategoryCopyBackgroundColor', node)
        if value is not None and 'OPFCategoryCopyBackgroundColor' not in already_processed:
            already_processed.add('OPFCategoryCopyBackgroundColor')
            self.OPFCategoryCopyBackgroundColor = value
        value = find_attr_value_('OPFCategoryCopyName', node)
        if value is not None and 'OPFCategoryCopyName' not in already_processed:
            already_processed.add('OPFCategoryCopyName')
            self.OPFCategoryCopyName = value
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class categoryType


class OPFMessageCopyMeetingDataType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyMeetingDataType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyMeetingDataType.subclass:
            return OPFMessageCopyMeetingDataType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyMeetingDataType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyMeetingDataType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyMeetingDataType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyMeetingDataType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyMeetingDataType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyMeetingDataType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyMeetingDataType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageCopyMeetingDataType


class OPFMessageCopyReferencesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyReferencesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyReferencesType.subclass:
            return OPFMessageCopyReferencesType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyReferencesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyReferencesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyReferencesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyReferencesType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyReferencesType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyReferencesType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyReferencesType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageCopyReferencesType


class OPFMessageCopyInReplyToType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyInReplyToType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyInReplyToType.subclass:
            return OPFMessageCopyInReplyToType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyInReplyToType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyInReplyToType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyInReplyToType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyInReplyToType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyInReplyToType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyInReplyToType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyInReplyToType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageCopyInReplyToType


class OPFMessageCopyBCCAddressesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, emailAddress=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        if emailAddress is None:
            self.emailAddress = []
        else:
            self.emailAddress = emailAddress
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyBCCAddressesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyBCCAddressesType.subclass:
            return OPFMessageCopyBCCAddressesType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyBCCAddressesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_emailAddress(self): return self.emailAddress
    def set_emailAddress(self, emailAddress): self.emailAddress = emailAddress
    def add_emailAddress(self, value): self.emailAddress.append(value)
    def insert_emailAddress_at(self, index, value): self.emailAddress.insert(index, value)
    def replace_emailAddress_at(self, index, value): self.emailAddress[index] = value
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def hasContent_(self):
        if (
            self.emailAddress
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyBCCAddressesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyBCCAddressesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyBCCAddressesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyBCCAddressesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyBCCAddressesType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyBCCAddressesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for emailAddress_ in self.emailAddress:
            emailAddress_.export(outfile, level, namespace_, name_='emailAddress', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'emailAddress':
            obj_ = emailAddress.factory()
            obj_.build(child_)
            self.emailAddress.append(obj_)
            obj_.original_tagname_ = 'emailAddress'
# end class OPFMessageCopyBCCAddressesType


class OPFMessageCopyReplyToAddressesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, emailAddress=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        if emailAddress is None:
            self.emailAddress = []
        else:
            self.emailAddress = emailAddress
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyReplyToAddressesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyReplyToAddressesType.subclass:
            return OPFMessageCopyReplyToAddressesType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyReplyToAddressesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_emailAddress(self): return self.emailAddress
    def set_emailAddress(self, emailAddress): self.emailAddress = emailAddress
    def add_emailAddress(self, value): self.emailAddress.append(value)
    def insert_emailAddress_at(self, index, value): self.emailAddress.insert(index, value)
    def replace_emailAddress_at(self, index, value): self.emailAddress[index] = value
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def hasContent_(self):
        if (
            self.emailAddress
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyReplyToAddressesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyReplyToAddressesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyReplyToAddressesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyReplyToAddressesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyReplyToAddressesType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyReplyToAddressesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for emailAddress_ in self.emailAddress:
            emailAddress_.export(outfile, level, namespace_, name_='emailAddress', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'emailAddress':
            obj_ = emailAddress.factory()
            obj_.build(child_)
            self.emailAddress.append(obj_)
            obj_.original_tagname_ = 'emailAddress'
# end class OPFMessageCopyReplyToAddressesType


class OPFMessageCopySenderAddressType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, emailAddress=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        if emailAddress is None:
            self.emailAddress = []
        else:
            self.emailAddress = emailAddress
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopySenderAddressType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopySenderAddressType.subclass:
            return OPFMessageCopySenderAddressType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopySenderAddressType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_emailAddress(self): return self.emailAddress
    def set_emailAddress(self, emailAddress): self.emailAddress = emailAddress
    def add_emailAddress(self, value): self.emailAddress.append(value)
    def insert_emailAddress_at(self, index, value): self.emailAddress.insert(index, value)
    def replace_emailAddress_at(self, index, value): self.emailAddress[index] = value
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def hasContent_(self):
        if (
            self.emailAddress
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopySenderAddressType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopySenderAddressType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopySenderAddressType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopySenderAddressType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopySenderAddressType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopySenderAddressType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for emailAddress_ in self.emailAddress:
            emailAddress_.export(outfile, level, namespace_, name_='emailAddress', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'emailAddress':
            obj_ = emailAddress.factory()
            obj_.build(child_)
            self.emailAddress.append(obj_)
            obj_.original_tagname_ = 'emailAddress'
# end class OPFMessageCopySenderAddressType


class OPFMessageCopyToAddressesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, emailAddress=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        if emailAddress is None:
            self.emailAddress = []
        else:
            self.emailAddress = emailAddress
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyToAddressesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyToAddressesType.subclass:
            return OPFMessageCopyToAddressesType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyToAddressesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_emailAddress(self): return self.emailAddress
    def set_emailAddress(self, emailAddress): self.emailAddress = emailAddress
    def add_emailAddress(self, value): self.emailAddress.append(value)
    def insert_emailAddress_at(self, index, value): self.emailAddress.insert(index, value)
    def replace_emailAddress_at(self, index, value): self.emailAddress[index] = value
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def hasContent_(self):
        if (
            self.emailAddress
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyToAddressesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyToAddressesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyToAddressesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyToAddressesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyToAddressesType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyToAddressesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for emailAddress_ in self.emailAddress:
            emailAddress_.export(outfile, level, namespace_, name_='emailAddress', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'emailAddress':
            obj_ = emailAddress.factory()
            obj_.build(child_)
            self.emailAddress.append(obj_)
            obj_.original_tagname_ = 'emailAddress'
# end class OPFMessageCopyToAddressesType


class OPFMessageCopyThreadTopicType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyThreadTopicType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyThreadTopicType.subclass:
            return OPFMessageCopyThreadTopicType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyThreadTopicType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyThreadTopicType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyThreadTopicType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyThreadTopicType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyThreadTopicType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyThreadTopicType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyThreadTopicType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageCopyThreadTopicType


class OPFMessageCopyCompletedDateTimeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyCompletedDateTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyCompletedDateTimeType.subclass:
            return OPFMessageCopyCompletedDateTimeType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyCompletedDateTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyCompletedDateTimeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyCompletedDateTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyCompletedDateTimeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyCompletedDateTimeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyCompletedDateTimeType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyCompletedDateTimeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageCopyCompletedDateTimeType


class OPFMessageCopyDueDateTimeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyDueDateTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyDueDateTimeType.subclass:
            return OPFMessageCopyDueDateTimeType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyDueDateTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyDueDateTimeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyDueDateTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyDueDateTimeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyDueDateTimeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyDueDateTimeType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyDueDateTimeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageCopyDueDateTimeType


class OPFMessageCopyStartDateTimeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyStartDateTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyStartDateTimeType.subclass:
            return OPFMessageCopyStartDateTimeType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyStartDateTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyStartDateTimeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyStartDateTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyStartDateTimeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyStartDateTimeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyStartDateTimeType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyStartDateTimeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageCopyStartDateTimeType


class OPFMessageCopyModDateType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyModDateType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyModDateType.subclass:
            return OPFMessageCopyModDateType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyModDateType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyModDateType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyModDateType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyModDateType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyModDateType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyModDateType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyModDateType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageCopyModDateType


class OPFMessageCopySentTimeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopySentTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopySentTimeType.subclass:
            return OPFMessageCopySentTimeType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopySentTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopySentTimeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopySentTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopySentTimeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopySentTimeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopySentTimeType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopySentTimeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageCopySentTimeType


class OPFMessageCopyThreadIndexType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyThreadIndexType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyThreadIndexType.subclass:
            return OPFMessageCopyThreadIndexType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyThreadIndexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyThreadIndexType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyThreadIndexType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyThreadIndexType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyThreadIndexType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyThreadIndexType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyThreadIndexType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageCopyThreadIndexType


class OPFMessageCopyReminderDateTimeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyReminderDateTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyReminderDateTimeType.subclass:
            return OPFMessageCopyReminderDateTimeType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyReminderDateTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyReminderDateTimeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyReminderDateTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyReminderDateTimeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyReminderDateTimeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyReminderDateTimeType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyReminderDateTimeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageCopyReminderDateTimeType


class OPFMessageCopyReceivedRepresentingNameType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyReceivedRepresentingNameType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyReceivedRepresentingNameType.subclass:
            return OPFMessageCopyReceivedRepresentingNameType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyReceivedRepresentingNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyReceivedRepresentingNameType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyReceivedRepresentingNameType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyReceivedRepresentingNameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyReceivedRepresentingNameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyReceivedRepresentingNameType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyReceivedRepresentingNameType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageCopyReceivedRepresentingNameType


class OPFMessageCopyReceivedTimeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyReceivedTimeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyReceivedTimeType.subclass:
            return OPFMessageCopyReceivedTimeType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyReceivedTimeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyReceivedTimeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyReceivedTimeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyReceivedTimeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyReceivedTimeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyReceivedTimeType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyReceivedTimeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageCopyReceivedTimeType


class OPFMessageGetCalendarAcceptStatusType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageGetCalendarAcceptStatusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageGetCalendarAcceptStatusType.subclass:
            return OPFMessageGetCalendarAcceptStatusType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageGetCalendarAcceptStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageGetCalendarAcceptStatusType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageGetCalendarAcceptStatusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageGetCalendarAcceptStatusType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageGetCalendarAcceptStatusType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageGetCalendarAcceptStatusType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageGetCalendarAcceptStatusType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageGetCalendarAcceptStatusType


class OPFMessageGetSendReadReceiptType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageGetSendReadReceiptType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageGetSendReadReceiptType.subclass:
            return OPFMessageGetSendReadReceiptType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageGetSendReadReceiptType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageGetSendReadReceiptType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageGetSendReadReceiptType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageGetSendReadReceiptType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageGetSendReadReceiptType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageGetSendReadReceiptType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageGetSendReadReceiptType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageGetSendReadReceiptType


class OPFMessageGetMentionedMeType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageGetMentionedMeType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageGetMentionedMeType.subclass:
            return OPFMessageGetMentionedMeType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageGetMentionedMeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageGetMentionedMeType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageGetMentionedMeType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageGetMentionedMeType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageGetMentionedMeType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageGetMentionedMeType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageGetMentionedMeType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageGetMentionedMeType


class OPFMessageGetInferenceClassificationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageGetInferenceClassificationType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageGetInferenceClassificationType.subclass:
            return OPFMessageGetInferenceClassificationType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageGetInferenceClassificationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageGetInferenceClassificationType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageGetInferenceClassificationType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageGetInferenceClassificationType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageGetInferenceClassificationType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageGetInferenceClassificationType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageGetInferenceClassificationType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageGetInferenceClassificationType


class OPFMessageGetHasRichTextType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageGetHasRichTextType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageGetHasRichTextType.subclass:
            return OPFMessageGetHasRichTextType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageGetHasRichTextType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageGetHasRichTextType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageGetHasRichTextType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageGetHasRichTextType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageGetHasRichTextType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageGetHasRichTextType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageGetHasRichTextType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageGetHasRichTextType


class OPFMessageGetIsReadType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageGetIsReadType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageGetIsReadType.subclass:
            return OPFMessageGetIsReadType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageGetIsReadType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageGetIsReadType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageGetIsReadType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageGetIsReadType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageGetIsReadType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageGetIsReadType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageGetIsReadType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageGetIsReadType


class OPFMessageGetOverrideEncodingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageGetOverrideEncodingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageGetOverrideEncodingType.subclass:
            return OPFMessageGetOverrideEncodingType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageGetOverrideEncodingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageGetOverrideEncodingType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageGetOverrideEncodingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageGetOverrideEncodingType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageGetOverrideEncodingType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageGetOverrideEncodingType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageGetOverrideEncodingType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageGetOverrideEncodingType


class OPFMessageGetPriorityType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageGetPriorityType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageGetPriorityType.subclass:
            return OPFMessageGetPriorityType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageGetPriorityType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageGetPriorityType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageGetPriorityType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageGetPriorityType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageGetPriorityType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageGetPriorityType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageGetPriorityType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageGetPriorityType


class OPFMessageCopySubjectType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopySubjectType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopySubjectType.subclass:
            return OPFMessageCopySubjectType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopySubjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopySubjectType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopySubjectType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopySubjectType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopySubjectType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopySubjectType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopySubjectType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageCopySubjectType


class OPFMessageCopySourceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopySourceType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopySourceType.subclass:
            return OPFMessageCopySourceType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopySourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopySourceType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopySourceType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopySourceType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopySourceType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopySourceType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopySourceType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageCopySourceType


class OPFMessageCopyGetFlagStatusType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyGetFlagStatusType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyGetFlagStatusType.subclass:
            return OPFMessageCopyGetFlagStatusType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyGetFlagStatusType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyGetFlagStatusType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyGetFlagStatusType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyGetFlagStatusType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyGetFlagStatusType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyGetFlagStatusType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyGetFlagStatusType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageCopyGetFlagStatusType


class OPFMessageGetWasSentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageGetWasSentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageGetWasSentType.subclass:
            return OPFMessageGetWasSentType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageGetWasSentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageGetWasSentType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageGetWasSentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageGetWasSentType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageGetWasSentType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageGetWasSentType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageGetWasSentType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageGetWasSentType


class OPFMessageIsCalendarMessageType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageIsCalendarMessageType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageIsCalendarMessageType.subclass:
            return OPFMessageIsCalendarMessageType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageIsCalendarMessageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageIsCalendarMessageType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageIsCalendarMessageType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageIsCalendarMessageType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageIsCalendarMessageType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageIsCalendarMessageType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageIsCalendarMessageType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageIsCalendarMessageType


class OPFMessageIsMeetingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageIsMeetingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageIsMeetingType.subclass:
            return OPFMessageIsMeetingType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageIsMeetingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageIsMeetingType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageIsMeetingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageIsMeetingType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageIsMeetingType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageIsMeetingType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageIsMeetingType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageIsMeetingType


class OPFMessageIsOutgoingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageIsOutgoingType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageIsOutgoingType.subclass:
            return OPFMessageIsOutgoingType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageIsOutgoingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageIsOutgoingType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageIsOutgoingType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageIsOutgoingType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageIsOutgoingType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageIsOutgoingType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageIsOutgoingType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageIsOutgoingType


class OPFMessageIsOutgoingMeetingResponseType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageIsOutgoingMeetingResponseType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageIsOutgoingMeetingResponseType.subclass:
            return OPFMessageIsOutgoingMeetingResponseType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageIsOutgoingMeetingResponseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageIsOutgoingMeetingResponseType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageIsOutgoingMeetingResponseType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageIsOutgoingMeetingResponseType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageIsOutgoingMeetingResponseType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageIsOutgoingMeetingResponseType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageIsOutgoingMeetingResponseType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageIsOutgoingMeetingResponseType


class OPFMessageCopyMessageIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyMessageIDType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyMessageIDType.subclass:
            return OPFMessageCopyMessageIDType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyMessageIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyMessageIDType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyMessageIDType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyMessageIDType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyMessageIDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyMessageIDType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyMessageIDType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageCopyMessageIDType


class OPFMessageGetHasHTMLType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageGetHasHTMLType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageGetHasHTMLType.subclass:
            return OPFMessageGetHasHTMLType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageGetHasHTMLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageGetHasHTMLType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageGetHasHTMLType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageGetHasHTMLType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageGetHasHTMLType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageGetHasHTMLType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageGetHasHTMLType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageGetHasHTMLType


class OPFMessageCopyBodyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyBodyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyBodyType.subclass:
            return OPFMessageCopyBodyType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyBodyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyBodyType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyBodyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyBodyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyBodyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyBodyType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyBodyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageCopyBodyType


class OPFMessageCopyHTMLBodyType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, valueOf_=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyHTMLBodyType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyHTMLBodyType.subclass:
            return OPFMessageCopyHTMLBodyType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyHTMLBodyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            (1 if type(self.valueOf_) in [int,float] else self.valueOf_)
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyHTMLBodyType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyHTMLBodyType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyHTMLBodyType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(self.convert_unicode(self.valueOf_))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyHTMLBodyType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyHTMLBodyType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyHTMLBodyType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class OPFMessageCopyHTMLBodyType


class OPFMessageCopyFromAddressesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, emailAddress=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        if emailAddress is None:
            self.emailAddress = []
        else:
            self.emailAddress = emailAddress
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyFromAddressesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyFromAddressesType.subclass:
            return OPFMessageCopyFromAddressesType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyFromAddressesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_emailAddress(self): return self.emailAddress
    def set_emailAddress(self, emailAddress): self.emailAddress = emailAddress
    def add_emailAddress(self, value): self.emailAddress.append(value)
    def insert_emailAddress_at(self, index, value): self.emailAddress.insert(index, value)
    def replace_emailAddress_at(self, index, value): self.emailAddress[index] = value
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def hasContent_(self):
        if (
            self.emailAddress
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyFromAddressesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyFromAddressesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyFromAddressesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyFromAddressesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyFromAddressesType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyFromAddressesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for emailAddress_ in self.emailAddress:
            emailAddress_.export(outfile, level, namespace_, name_='emailAddress', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'emailAddress':
            obj_ = emailAddress.factory()
            obj_.build(child_)
            self.emailAddress.append(obj_)
            obj_.original_tagname_ = 'emailAddress'
# end class OPFMessageCopyFromAddressesType


class OPFMessageCopyCCAddressesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, emailAddress=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        if emailAddress is None:
            self.emailAddress = []
        else:
            self.emailAddress = emailAddress
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyCCAddressesType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyCCAddressesType.subclass:
            return OPFMessageCopyCCAddressesType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyCCAddressesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_emailAddress(self): return self.emailAddress
    def set_emailAddress(self, emailAddress): self.emailAddress = emailAddress
    def add_emailAddress(self, value): self.emailAddress.append(value)
    def insert_emailAddress_at(self, index, value): self.emailAddress.insert(index, value)
    def replace_emailAddress_at(self, index, value): self.emailAddress[index] = value
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def hasContent_(self):
        if (
            self.emailAddress
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyCCAddressesType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyCCAddressesType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyCCAddressesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyCCAddressesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyCCAddressesType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyCCAddressesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for emailAddress_ in self.emailAddress:
            emailAddress_.export(outfile, level, namespace_, name_='emailAddress', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'emailAddress':
            obj_ = emailAddress.factory()
            obj_.build(child_)
            self.emailAddress.append(obj_)
            obj_.original_tagname_ = 'emailAddress'
# end class OPFMessageCopyCCAddressesType


class OPFMessageCopyAttachmentListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, space=None, messageAttachment=None):
        self.original_tagname_ = None
        self.space = _cast(None, space)
        if messageAttachment is None:
            self.messageAttachment = []
        else:
            self.messageAttachment = messageAttachment
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, OPFMessageCopyAttachmentListType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if OPFMessageCopyAttachmentListType.subclass:
            return OPFMessageCopyAttachmentListType.subclass(*args_, **kwargs_)
        else:
            return OPFMessageCopyAttachmentListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_messageAttachment(self): return self.messageAttachment
    def set_messageAttachment(self, messageAttachment): self.messageAttachment = messageAttachment
    def add_messageAttachment(self, value): self.messageAttachment.append(value)
    def insert_messageAttachment_at(self, index, value): self.messageAttachment.insert(index, value)
    def replace_messageAttachment_at(self, index, value): self.messageAttachment[index] = value
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def hasContent_(self):
        if (
            self.messageAttachment
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OPFMessageCopyAttachmentListType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('OPFMessageCopyAttachmentListType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OPFMessageCopyAttachmentListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OPFMessageCopyAttachmentListType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OPFMessageCopyAttachmentListType'):
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='OPFMessageCopyAttachmentListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for messageAttachment_ in self.messageAttachment:
            messageAttachment_.export(outfile, level, namespace_, name_='messageAttachment', pretty_print=pretty_print)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'messageAttachment':
            obj_ = messageAttachmentType.factory()
            obj_.build(child_)
            self.messageAttachment.append(obj_)
            obj_.original_tagname_ = 'messageAttachment'
# end class OPFMessageCopyAttachmentListType


class messageAttachmentType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, OPFAttachmentContentExtension=None, OPFAttachmentContentFileSize=None, OPFAttachmentContentID=None, OPFAttachmentContentType=None, OPFAttachmentName=None, OPFAttachmentURL=None, space=None):
        self.original_tagname_ = None
        self.OPFAttachmentContentExtension = _cast(None, OPFAttachmentContentExtension)
        self.OPFAttachmentContentFileSize = _cast(None, OPFAttachmentContentFileSize)
        self.OPFAttachmentContentID = _cast(None, OPFAttachmentContentID)
        self.OPFAttachmentContentType = _cast(None, OPFAttachmentContentType)
        self.OPFAttachmentName = _cast(None, OPFAttachmentName)
        self.OPFAttachmentURL = _cast(None, OPFAttachmentURL)
        self.space = _cast(None, space)
    def factory(*args_, **kwargs_):
        if CurrentSubclassModule_ is not None:
            subclass = getSubclassFromModule_(
                CurrentSubclassModule_, messageAttachmentType)
            if subclass is not None:
                return subclass(*args_, **kwargs_)
        if messageAttachmentType.subclass:
            return messageAttachmentType.subclass(*args_, **kwargs_)
        else:
            return messageAttachmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_OPFAttachmentContentExtension(self): return self.OPFAttachmentContentExtension
    def set_OPFAttachmentContentExtension(self, OPFAttachmentContentExtension): self.OPFAttachmentContentExtension = OPFAttachmentContentExtension
    def get_OPFAttachmentContentFileSize(self): return self.OPFAttachmentContentFileSize
    def set_OPFAttachmentContentFileSize(self, OPFAttachmentContentFileSize): self.OPFAttachmentContentFileSize = OPFAttachmentContentFileSize
    def get_OPFAttachmentContentID(self): return self.OPFAttachmentContentID
    def set_OPFAttachmentContentID(self, OPFAttachmentContentID): self.OPFAttachmentContentID = OPFAttachmentContentID
    def get_OPFAttachmentContentType(self): return self.OPFAttachmentContentType
    def set_OPFAttachmentContentType(self, OPFAttachmentContentType): self.OPFAttachmentContentType = OPFAttachmentContentType
    def get_OPFAttachmentName(self): return self.OPFAttachmentName
    def set_OPFAttachmentName(self, OPFAttachmentName): self.OPFAttachmentName = OPFAttachmentName
    def get_OPFAttachmentURL(self): return self.OPFAttachmentURL
    def set_OPFAttachmentURL(self, OPFAttachmentURL): self.OPFAttachmentURL = OPFAttachmentURL
    def get_space(self): return self.space
    def set_space(self, space): self.space = space
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='messageAttachmentType', namespacedef_='', pretty_print=True):
        imported_ns_def_ = GenerateDSNamespaceDefs_.get('messageAttachmentType')
        if imported_ns_def_ is not None:
            namespacedef_ = imported_ns_def_
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='messageAttachmentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='messageAttachmentType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='messageAttachmentType'):
        if self.OPFAttachmentContentExtension is not None and 'OPFAttachmentContentExtension' not in already_processed:
            already_processed.add('OPFAttachmentContentExtension')
            outfile.write(' OPFAttachmentContentExtension=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OPFAttachmentContentExtension), input_name='OPFAttachmentContentExtension')), ))
        if self.OPFAttachmentContentFileSize is not None and 'OPFAttachmentContentFileSize' not in already_processed:
            already_processed.add('OPFAttachmentContentFileSize')
            outfile.write(' OPFAttachmentContentFileSize=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OPFAttachmentContentFileSize), input_name='OPFAttachmentContentFileSize')), ))
        if self.OPFAttachmentContentID is not None and 'OPFAttachmentContentID' not in already_processed:
            already_processed.add('OPFAttachmentContentID')
            outfile.write(' OPFAttachmentContentID=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OPFAttachmentContentID), input_name='OPFAttachmentContentID')), ))
        if self.OPFAttachmentContentType is not None and 'OPFAttachmentContentType' not in already_processed:
            already_processed.add('OPFAttachmentContentType')
            outfile.write(' OPFAttachmentContentType=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OPFAttachmentContentType), input_name='OPFAttachmentContentType')), ))
        if self.OPFAttachmentName is not None and 'OPFAttachmentName' not in already_processed:
            already_processed.add('OPFAttachmentName')
            outfile.write(' OPFAttachmentName=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OPFAttachmentName), input_name='OPFAttachmentName')), ))
        if self.OPFAttachmentURL is not None and 'OPFAttachmentURL' not in already_processed:
            already_processed.add('OPFAttachmentURL')
            outfile.write(' OPFAttachmentURL=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.OPFAttachmentURL), input_name='OPFAttachmentURL')), ))
        if self.space is not None and 'space' not in already_processed:
            already_processed.add('space')
            outfile.write(' space=%s' % (self.gds_encode(self.gds_format_string(quote_attrib(self.space), input_name='space')), ))
    def exportChildren(self, outfile, level, namespace_='', name_='messageAttachmentType', fromsubclass_=False, pretty_print=True):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('OPFAttachmentContentExtension', node)
        if value is not None and 'OPFAttachmentContentExtension' not in already_processed:
            already_processed.add('OPFAttachmentContentExtension')
            self.OPFAttachmentContentExtension = value
        value = find_attr_value_('OPFAttachmentContentFileSize', node)
        if value is not None and 'OPFAttachmentContentFileSize' not in already_processed:
            already_processed.add('OPFAttachmentContentFileSize')
            self.OPFAttachmentContentFileSize = value
        value = find_attr_value_('OPFAttachmentContentID', node)
        if value is not None and 'OPFAttachmentContentID' not in already_processed:
            already_processed.add('OPFAttachmentContentID')
            self.OPFAttachmentContentID = value
        value = find_attr_value_('OPFAttachmentContentType', node)
        if value is not None and 'OPFAttachmentContentType' not in already_processed:
            already_processed.add('OPFAttachmentContentType')
            self.OPFAttachmentContentType = value
        value = find_attr_value_('OPFAttachmentName', node)
        if value is not None and 'OPFAttachmentName' not in already_processed:
            already_processed.add('OPFAttachmentName')
            self.OPFAttachmentName = value
        value = find_attr_value_('OPFAttachmentURL', node)
        if value is not None and 'OPFAttachmentURL' not in already_processed:
            already_processed.add('OPFAttachmentURL')
            self.OPFAttachmentURL = value
        value = find_attr_value_('space', node)
        if value is not None and 'space' not in already_processed:
            already_processed.add('space')
            self.space = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class messageAttachmentType


GDSClassesMapping = {
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'emails'
        rootClass = emails
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'emails'
        rootClass = emails
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    '''Parse a string, create the object tree, and export it.

    Arguments:
    - inString -- A string.  This XML fragment should not start
      with an XML declaration containing an encoding.
    - silence -- A boolean.  If False, export the object.
    Returns -- The root object in the tree.
    '''
    parser = None
    rootNode= parsexmlstring_(inString, parser)
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'emails'
        rootClass = emails
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'emails'
        rootClass = emails
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from emails import *\n\n')
        sys.stdout.write('import emails as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "OPFCategoryCopyBackgroundColorType",
    "OPFCategoryCopyNameType",
    "OPFMessageCopyAttachmentListType",
    "OPFMessageCopyBCCAddressesType",
    "OPFMessageCopyBodyType",
    "OPFMessageCopyCCAddressesType",
    "OPFMessageCopyCategoryListType",
    "OPFMessageCopyCompletedDateTimeType",
    "OPFMessageCopyDueDateTimeType",
    "OPFMessageCopyFromAddressesType",
    "OPFMessageCopyGetFlagStatusType",
    "OPFMessageCopyHTMLBodyType",
    "OPFMessageCopyInReplyToType",
    "OPFMessageCopyMeetingDataType",
    "OPFMessageCopyMessageIDType",
    "OPFMessageCopyModDateType",
    "OPFMessageCopyPrimaryCategoryType",
    "OPFMessageCopyReceivedRepresentingNameType",
    "OPFMessageCopyReceivedTimeType",
    "OPFMessageCopyReferencesType",
    "OPFMessageCopyReminderDateTimeType",
    "OPFMessageCopyReplyToAddressesType",
    "OPFMessageCopySenderAddressType",
    "OPFMessageCopySentTimeType",
    "OPFMessageCopySourceType",
    "OPFMessageCopyStartDateTimeType",
    "OPFMessageCopySubjectType",
    "OPFMessageCopyThreadIndexType",
    "OPFMessageCopyThreadTopicType",
    "OPFMessageCopyToAddressesType",
    "OPFMessageGetCalendarAcceptStatusType",
    "OPFMessageGetHasHTMLType",
    "OPFMessageGetHasRichTextType",
    "OPFMessageGetInferenceClassificationType",
    "OPFMessageGetIsReadType",
    "OPFMessageGetMentionedMeType",
    "OPFMessageGetOverrideEncodingType",
    "OPFMessageGetPriorityType",
    "OPFMessageGetSendReadReceiptType",
    "OPFMessageGetWasSentType",
    "OPFMessageIsCalendarMessageType",
    "OPFMessageIsMeetingType",
    "OPFMessageIsOutgoingMeetingResponseType",
    "OPFMessageIsOutgoingType",
    "categoryType",
    "emailAddress",
    "emailType",
    "emails",
    "messageAttachmentType"
]
